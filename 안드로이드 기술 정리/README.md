## 사용자 인터페이스 정보
앱의 사용자 `인터페이스(UI)`는 화면에 표시되는 Text, Image, Button 등 여러 유형의 요소이다. UI를 통해 앱은 사용자에게 콘텐츠를 표시하고 사용자는 앱과 상호작용할 수 있다.<br/><br/>

이때, 위에서 언급한 여러 유형의 요소들을 `View`라고 한다. 즉, 앱에 표시되는 대부분의 것들은 View라고 볼 수 있다. View는 화면에 자체적으로 있을 수 없다. 예를 들자면 Image옆에 Text가 있고 그 아래에 Button이 있다고 했을 때, 이 요소들을 정렬 시킬 수 있는 컨테이너가 필요하다.
<br/><br/>

View는 `ViewGroup`이라는 View 객체가 있을 수 있는 컨테이너에 배치된다. ViewGroup의 한 종류로 `ConstraintLayout`이 있다.<br/>

![image](https://user-images.githubusercontent.com/52282493/157878072-05acce1c-7c74-43f0-a3c5-392cb30e3608.png)

<br/><br/>

---
## 크기 측정 단위
안드로이드에서 View나 ViewGroup의 크기를 지정할 때 `wrap_content`, `match_parent`, `dp`, `sp` 등이 있다.<br/>

- `dp`는 Density-independent Pixels로 `밀도 독립형 픽셀`이라고 한다. UI의 레이아웃을 정의할 때 치수나 위치를 dp 방식으로 표현하기 위해 사용해야 하는 가상 픽셀 단위이다.<br/>
같은 화면 사이즈(크기)를 가진 두 대의 휴대폰 기기가 있을 때, 스펙 차이 등의 이유로 두 화면의 밀도는 다를 수 있다. 밀도가 다르다는 것은 인치당 도트(화소, 픽셀) 수가 다르다는 것을 의미한다.<br/>
![image](https://user-images.githubusercontent.com/52282493/157889215-16630f73-74c0-491b-bea5-0a047cf72308.png) <br/><br/>
안드로이드에서 width, height 측정 단위를 dp를 사용하면 밀도가 다른 기기라도 같은 사이즈로 보이도록 해준다.<br/>
즉, dp는 다양한 기기에서 UI 요소들의 크기에 일관성을 부여할 수 있다.

- `sp`는 Scale-independent Pixels로 `배율 독립형 픽셀`이라고 한다. dp가 화면상의 거리 측정 단위라면 sp는 글꼴 크기 측정 단위이다.<br/>
sp는 텍스트 크기를 지정할 때 화면 밀도와 사용자의 환경설정 모두에 따라 조정이 되기 때문에 텍스트에서 권장되는 단위이다.

<br/><br/>

---
## 안드로이드 4대 컴포넌트
안드로이드의 4대 컴포넌트는 **Activity**, **Service**, **Broadcast Receiver**, **Content Provider**이다.<br/>
컴포넌트는 앱의 구성 단위이며, 앱은 컴포넌트를 조합하여 만들어진다. 각 컴포넌트들은 하나의 독립된 형태로 존재하고, 정해진 역할을 수행한다. 인텐트(Intent)를 통해 각각의 컴포넌트들은 상호작용한다.

![image](https://user-images.githubusercontent.com/52282493/158025698-37aa67f1-f366-4a9b-a52f-305ea0a051ac.png)

### `액티비티(Activity)`
Activity는 화면을 구성하는 가장 기본적인 컴포넌트이다.<br/>
- Activity 클래스를 상속받아 사용한다.
- 최소 하나 이상의 Activity를 가져야한다.
- 동시에 두 개 이상의 Activity를 표시할 수 없다.
- Activity는 하나 이상의 View를 가질 수 있다.
- Intent를 통해 다른 Activity를 불러올 수 있다.


### `서비스(Service)`
서비스는 눈에 보이는 화면(Activity)과 상관없이 백그라운드에서 동작하는 컴포넌트이다.<br/>

서비스는 일반적으로 화면 없이 동작하는 프로그램을 말한다. 다른 말로는 데몬(Daemon), 백그라운드 프로세스(Background Process)라고도 한다. 서비스의 작업으로 음악 프로그램을 들으면서 다른 앱을 사용하는 것을 예로 들 수 있다.<br/>

- 앱이 종료되어도 서비스는 백그라운드에서 실행되기 때문에 계속 작동한다.(다른 앱으로 이동해도 작동.)
- 모든 서비스는 Service 클래스를 상속받아 사용한다.
- UI가 동작하는 스레드에서 동작한다.
- Activity와 마찬가지로 생명주기를 갖고 있다.<br/>

![image](https://user-images.githubusercontent.com/52282493/158046850-ba15e721-4a3b-4305-99a9-1ebf2ecba912.png) <br/>
왼쪽의 다이어그램은 startService()로 생성된 경우의 서비스, 오른쪽은 bindService()로 생성된 경우의 서비스이다. ([참고](https://developer.android.com/guide/components/services?hl=ko)) 


### `방송 수신자(Broadcast Receiver)`
방송 수신자는 Broadcasting Message가 발생하면 반응하는 컴포넌트이다.<br/>

방송 수신자를 활용하면 안드로이드에서 발생하는 많은 이벤트(문자 메시지, 배터리 방전, 날짜 변경 등)를 감지고하고 이를 처리하는 앱을 작성할 수 있다.<br/>

문자 메시지 도착, 배터리 상태, SD 카드 탈부착 등이 발생하면 broadcast 신호를 보내는데 이 신호를 Broadcasting Message라고 할 수 있다. 이런 broadcast 신호를 받아서 처리하는 것이 Broadcast Receiver이다.<br/>

- 디바이스에서 발생하는 이벤트를 정보를 받고 반응한다.
- 일반적으로 UI를 가지고 있지 않다.

### `콘텐트 제공자(Content Provider)`
콘텐트 제공자는 응용 프로그램 사이에 데이터를 공휴하기 위한 컴포넌트이다.<br/>

안드로이드는 보안상 앱에서 사용하는 데이터를 외부에서 접근할 수 없다. SQLite 등의 데이터는 자신의 앱에서만 사용할 수 있고 다른 앱에서는 사용할 수 없다. 이러한 파일이나 데이터베이스를 외부 앱에서 사용하게 하기 위해서 콘텐트 제공자(줄여서 CP)를 만들어서 외부로 제공해야 한다.<br/>

카카오톡이나 페이스북에서 전화번호부에 저장되어 있는 데이터베이스를 사용하는 것을 예로 들 수 있다.
- 콘텐트 제공자는 앱에 데이터를 제공한다.
- 콘텐트 제공자를 통해 다른 앱의 데이터를 쿼리하는 등의 변경이 가능하다.

<br/><br/>

---
## Activity 생명주기
액티비티 생명주기는 액티비티가 생성되는 시점부터 소멸되어 시스템에서 액티비티 리소스가 회수될 때까지의 주기를 말한다. 앱을 사용하는 유저들은 액티비티 간에 화면을 이동하거나 앱을 종료 할 때 액티비티 생명주기는 다양한 상태로 전환된다.<br/>

액티비티가 생명주기에 올바르게 응답하지 않으면 앱에 버그가 발생하여 사용자의 동작에 혼란을 주거나 앱의 안드로이드 시스템 리소스를 너무 많이 사용하게 될 수 있다.<br/>

![image](https://user-images.githubusercontent.com/52282493/158847929-6436e306-257a-4d71-b200-acb52d78f7cb.png) <br/>

앱이 실행 되면 onCreate(), onStart(), onResume() 순으로 호출이 되고,<br/>

뒤로 버튼, 홈 화면이 터치 되거나 종료되면 onPause(), onStop(), onDestroy()이 순서대로 호출된다.<br/>

홈이나 다른 액티비티에서 원래있던 액티비티로 돌아갈 때는 onRestart()가 호출된다.

- `onCreate()`
    - 모든 액티비티에서 구현해야 하는 메서드로 binding을 하는 등 액티비티의 일회성 초기화를 한다.
    - 전체 생명주기 동안에 **한 번**만 발생한다. 
    - 앱에서 onCreate()가 실행되면 액티비티가 생성된 것으로 간주된다.
- `onStart()`
    - onCreate() 메서드가 호출된 직후에 호출된다.
    - 화면에 진입할 때 실행되어야 하는 코드를 작성한다.
    - onStart()는 액티비티 생명주기에서 여러번 호출될 수 있다.
- `onResume()`
    - 액티비티 포커스를 제공하고 사용자가 상호작용할 수 있도록 하는 메서드이다.
    - 이벤트가 발생하여 앱에서 포커스가 없어지기 전까지 이 상태에 머무른다. 이벤트가 발생하고 난 뒤에는 시스템은 onPause()를 호출한다.
    - 공식문서에서 onStart()에서 코드 초기화 작업을 했다면 onStop()에서 리소스 해제 또는 종료 작업을 하고, onResume()에서 초기화 작업을 했다면 onPause()에서 리소스 해제 또는 종료 작업을 해야한다.
- `onPause()`
    - 앱이 백그라운드 상태이거나 다른 액티비티로 넘어가면 호출되며, 이 때 사용자의 포커스가 상실된다.
    - onPause()는 아주 잠깐 실행되는 메서드로 데이터 저장이나 네트워크 호출 등의 무거운 작업을 하면 안된다.
- `onStop()`
    - onPause() 이후에 호출되며 더 이상 앱이 표시되지 않는다.
    - onPause()에서 말한 무거운 작업을 이 곳에서 작업한다.
    - 메모리가 부족할 경우에는 onStop() 메서드가 호출되 않을 수 있다.
- `onDestroy()`
    - 액티비티가 소멸되기 전에 호출된다. 호출됨으로써 액티비티가 완전히 종료되었으며 가비지 컬렉션이 될 수 있음을 의미한다.
    - 호출된 이후에 시스템은 가비지 컬렉션과 같은 리소스들이 삭제될 수 있음을 인식하고 메모리 정리를 시작한다.
    - onCreate()처럼 onDestroy()는 리소스가 정리될 때 한 번만 호출된다.
    - onStop()에서 해제하지 않은 리소스들을 해제해야 한다.
    - onStop()처럼 메모리 부족시 호출되지 않고 앱이 종료될 수 있다.
- `onRestart()`
    - 앱이 onStop() 상태에 있다가(백그라운드에 있다가) 포그라운드로 돌아올 때 onCreate()가 실행되지 않고 onRestart()가 호출된다.

<br/><br/>

---
## Fragment 생명주기
Activity와 마찬가지로 Fragment도 리소스들이 생명주기 상태에 따라 리소스들이 초기화되고 메모리에서 삭제될 수 있다.<br/>

![image](https://user-images.githubusercontent.com/52282493/159151972-98aefb20-3773-49ee-b1b5-5a561886feb3.png) <br/>

프래그먼트 생명주기에는 위의 사진처럼 CREATED, STARTED, RESUMED, INITIALIZED, DESTROYED 로 다섯 가지 생명주기 상태가 있고, 각 상태에 따른 Callback 함수들이 있다.
- `onAttach()`
    - 액티비티에서 프래그먼트가 호출될 때 최초로 한 번 실행된다.
    - onAttach가 **context**를 인자로 받는데 이것을 사용해서 액티비티와 연결하여 이동할 수 있다.
- `onCreate()`
    - 프래그먼트가 생성될 때 호출되는 함수이다.
    - 액비티비와 마찬가지로 일회성 초기화를 하는 곳이다. 차이점이 있다면 액티비티는 onCreate에서 view나 ui관련 작업을 할 수 있지만, 프래그먼트에서는 불가능하다. 해당 작업은 **onCreateView()** 에서 할 수 있다.
- `onCreateView()`
    - 이 메서드에서 레이아웃을 확장한다. 다시 말하자면 레이아웃을 **inflate**하는 곳이다. 
    - inflate한 레이아웃을 바인딩을 할 수 있는 곳이다.
    - 프래그먼트에서 UI를 그리기 위해 `View`를 반환해야 한다. UI를 제공하지 않는다면 null을 반환하면 된다.
- `onViewCreated()`
    - View가 생성된 이후에 호출되는 메서드이다.
    - View의 초기값을 설정하는 로직이 들어간다. 예를 들어 LiveData의 observe 함수나 리사이클러뷰의 adapter를 초기화 하는 등의 작업을 한다.
- `onActivityCreated()`
    - 프래그먼트에서 onCreateView()를 마치고 액티비티에서 onCreate()가 호출되고 나서 호출되는 함수이다.
    - 액티비티와 프래그먼트의 View가 모두 생성되고 연결된 상태이다.
    - View를 변경하는 작업이 가능한 단계이다.
    - 현재는 사라진 메서드로 확인된다. 액티비티와 프래그먼트의 생명주기가 결합되기 때문에 이 부분을 고려하여 지원중단을 한 것 같다.
- `onStart()`
    - 프래그먼트가 사용자에게 보여지기 직전에 호출되는 함수이다.
    - 유저에게 프래그먼트가 보이도록 해준다.
    - 액티비티와 역할이 비슷하다.
- `onResume()`
    - 프래그먼트가 사용자에게 보여지는 단계이다.(화면에 보여지는 단계이다.)
    - 사용자에게와 상호작용을 할 수 있는 상태이다. 예를 들어 `ViewModel`을 호출하여 사용자와 계속 상호작용을 하게 한다. 
- `onPause()`
    - 프래그먼트의 일부가 가려지게 되면 실행되는 메서드이다.
    - 프래그먼트가 사용자와의 상호작용을 중지한다.
    - UI관련 처리를 정지하고, 중요한 데이터를 저장한다.
- `onStop()`
    - 프래그먼트가 완전히 가려지는 경우 실행되는 메서드이다.
    - onPause()에서 onStop()으로 이어진다.
    - 시스템에서 onStateInstance()를 호출하여 UI의 상태를 저장하기 때문에 앱에 돌아왔을 때 이전 상태가 그대로 보여진다.
- `onDestroyView()`
    - 프래그먼트의 View가 사라질 때 호출되는 함수이다.
    - 아직 프래그먼트 객체는 존재하는 상태이다.
- `onDestroy()`
    - 프래그먼트를 제거하기 직전에 실행된다.
- `onDetach()`
    - 프래그먼트를 제거를 완료하고 액티비티와의 연결을 해제할 때 실행된다.

<br/><br/>

---
## Context
Context는 애플리케이션 또는 액티비티 환경에 대한 전역 정보의 인터페이스이다.<br/>

알기 쉽게 설명하자면, 자신이 어떤 애플리케이션(or 액티비티)인지 알 수 있게 해주는 신분증 역할이라고 보면 된다.<br/><br/>

Context는 여러 컴포넌트들의 상위 추상 클래스이다. 안드로이드 컴포넌트 중 **액티비티**, **애플리케이션**, **서비스**는 **ContextWrapper**(Context를 직접 상속한 구현체)를 상속 받았기 때문에 만약 Context가 없다면 언급한 컴포넌트들은 사용(시작)할 수 없다.<br/>
![image](https://user-images.githubusercontent.com/52282493/159159402-430fdc66-8a72-4e21-9cc6-e63f1bb720c7.png)<br/>

예를 들어 액티비티 클래스는 Context의 상속을 받게 되는데 Context를 통해 Class나 시스템 자원(getResource, SharedPreferences) 등에 접근할 수 있게된다. 액티비티에서 `this`, `getBaseContext()`, `getApplicationContext()`를 통해 Context를 가져올 수 있다.(참고로 모두 다른 인스턴스이다.)<br/><br/>

Context는 **Application Context**와 **Activity Context**로 나눌 수 있다.<br/>
![image](https://user-images.githubusercontent.com/52282493/159164097-b7df5f18-6cab-45d2-8b4a-38d36f58e518.png)

### `Application Context`
Application Context는 싱클톤 객체이고, **getApplicationContext()**를 통해 얻을 수 있다.<br/>

Application의 생명주기에 영향을 받고, 애플리케이션 전역에서 사용할 라이브러리를 액티비티에서 초기화 하는데 있어서 Context가 필요할 때 Application Context를 사용하면 된다. 요약하면 오랫동안 지속되거나 앱 전역에서 사용할 Context가 필요할 때 Application Context를 이용하면 된다.

### `Activity Context`
Activity의 생명주기에 영향을 받기 때문에 현재의 Context와 분리되지 않는 생명주기를 가진 Context가 필요할 때 사용한다.<br/>

보통 Context가 현재 액티비티와 함께 소멸해야 하는 경우에 사용한다.

<br/><br/>

---
## 프로세스 및 스레드
[안드로이드 공식 사이트에서 정리된 프로세스 및 스레드 내용](https://developer.android.com/guide/components/processes-and-threads)<br/>

앱이 켜지고 컴포넌트(구성요소)가 시작될 때, 현재 앱에서 실행되고 있는 컴포넌트가 하나도 없으면 안드로이드 시스템은 앱을 위해 **하나의 스레드로** 앱의 **리눅스 프로세스를 시작**한다.<br/>

앱은 여러 컴포넌트들로 구성되어 있다. 기본적으로 앱의 모든 컴포넌트는 동일한 프로세스와 (메인)스레드에서 실행된다. 하지만 컴포넌트가 시작될 때, 앱에 이미 프로세스가 
실행되고 있다면 새로 시작한 그 컴포넌트는 그 프로세스에서 동작한다.<br/>

하지만 앱 내의 여러 컴포넌트가 각자 별도의 프로세스에서 실행되도록 재배치 할 수 있고, 각 프로세스에서 추가 스레드를 만들 수 있다.<br/><br/>

### `프로세스`
학교에 다닐 때 운영체제 수업에서 배운 프로세스 개념은 **실행을 위해 메모리에 올라온 동적 상태**를 의미했다. 그 외에도 여러 자료들을 찾아보면 **하나의 프로세스는 하나의 실행 중인 프로그램**, **운영체제에서 프로그램을 구성하는 기본 단위** 등 프로세스는 프로그램을 구성하는 필수 요소라는 것을 알 수 있다.<br/>

위에서 설명한대로 안드로이드 앱을 구성하는 모든 컴포넌트들은 기본적으로 동일한 프로세스에서 동작되고 이를 수정하지 않는다. 하지만 Manifest 파일에서 원하는 컴포넌트에 `android:processs` 속성을 이용해서 프로세스의 동작을 명시할 수 있다.<br/>

단, 프로세스들이 많아 질수록 앱이 전체적으로 사용하는 메모리가 증가한다. 안드로이드 시스템에서 메모리가 부족한 특정 시점에서 현재 사용되지 않는 프로세스를 종료한다.

### `스레드`
스레드는 프로세스 내에서 실행되는 작업 단위이다. 앱이 실행될 때 안드로이드 시스템에서 **Main**이라 불리는 스레드를 생성한다.<br/>

메인 스레드는 안드로이드 이벤트 생성 및 처리를 담당하고, 기타 여러 이벤트들을 사용자 인터페이스 위젯에 발송(연동)하는 역학을 하기 때문에 **UI 스레드**라고 불리기도 한다. 시스템 콜백 메서드들(onKeyDown(), LifeCycle과 관련된 메서드-onCreate())은 프로세스의 UI 스레드에서 동작한다.<br/>

스레드를 하나만 사용하는 **단일 스레드**의 경우 UI 스레드에서 모든 작업을 처리하게 되는데, 서버와 통신하는 작업이나 복잡한 연산 작업에 의해 오랜 시간 동안 UI 작업이 진행되지 않으면 ANR(Application Not Responding)이 발생하게 된다.<br/>

화면을 업데이트 하면서 파일을 다운로드 하는 등의 작업을 위해 여러개의 스레드를 사용하는 **멀티 스레드** 방식을 많이 사용한다.

<br/><br/>

---
## Clean Architecture(클린 아키텍처)
`클린 아키텍처`라는 개념은 Robert C.Martin이 [블로그](http://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)에 글을 올리면서 알려지게 되었다. 클린 아키텍처는 프로젝트를 계층을 두어 관심사를 분리하고, 분리된 각 계층이 각자의 역할을 갖고 서로 어떻게 의존하는지가 핵심이다. 클린 아키텍처가 도입된 프로젝트는 만들어야 할 클래스가 많아지지만 각 클래스의 코드는 간결해지고 가독성이 좋아진다. 또한 새로운 기능이나 내부 로직이 변경되어야 하는 이벤트가 생길 때 쉽게 처리할 수 있다. 

![image](https://user-images.githubusercontent.com/52282493/162902763-c4d41491-e653-4467-a0da-f494bb7e86b3.png)

---
## Task와 Process
`Task`는 애플리케이션에서 실행되는 프로세스를 관리하는 **작업** 단위를 말하고<br/>
`Processs`는 애플리케이션의 실행 단위를 말한다.

애플리케이션이 실행되면 Task와 Process가 하나씩 생성된다.<br/>
Process가 생성되면서 애플리케이션의 Activity들을 처리하게 되고, Task에 활성화된 Activity의 정보가 Stack 형태로 쌓이게 된다.<br/>
Task에 있는 Activity의 정보로 뒤로 가기 또는 홈에서 앱으로 돌아왔을 때 마지막에 활성화되어있던 Activity로 돌아갈 수 있다.

애플리케이션이 실행되면 Task와 Process가 하나씩 생성된다고 했는데, 다른 애플리케이션을 실행하면 어떻게 될까?<br/>
다른 애플리케이션을 실행하면 새로운 Task와 Process가 생성된다.<br/>
![task 1](https://user-images.githubusercontent.com/52282493/214497570-9ac72225-39ea-4060-a6eb-1dd4eaefdfe1.PNG)

예를 하나 들어보자.<br/>
갤러리 앱과 카메라 앱이 있다.<br/>
갤러리 앱에서 사진촬영 버튼을 눌렀더니 카메라 앱이 켜졌다.<br/>
카메라 앱이 켜진 상태에서 뒤로가기를 하면 원래 내가 보던 갤러리 앱의 화면이 보이고<br/>
기기의 홈 버튼을 누르고 갤러리 앱으로 돌아가면 카메라 앱이 켜져있다.<br/>
마치 하나의 앱처럼 동작한다.

갤러리 앱이 실행되면서 Process 하나가 생성되고, 카메라 앱이 실행되면서 또 다른 Process 프로세스가 생성됐다.<br/>
이 서로 다른 두 Process를 Task가 관리하기 때문에 가능하다.<br/>
두 Process가 하나의 Task의 백스택에 Activity 정보를 쌓았기 때문에<br/>
뒤로가기나 앱으로 돌아갔을 때 마지막에 사용한 Activity를 처리하는 것이다.

